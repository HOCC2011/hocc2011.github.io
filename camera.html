<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Camera Feed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 48px;
            width: 48px;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            margin-top: -22px; 
        }
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        /* Smooth fade transitions */
        .fade-enter {
            opacity: 0;
        }
        .fade-enter-active {
            opacity: 1;
            transition: opacity 300ms ease-in;
        }
        .fade-exit {
            opacity: 1;
        }
        .fade-exit-active {
            opacity: 0;
            transition: opacity 200ms ease-out;
        }
    </style>
</head>
<body class="bg-black font-sans text-gray-900 overflow-hidden w-full h-full fixed inset-0">

    <!-- Source Video (Hidden) -->
    <video id="sourceVideo" class="absolute top-0 left-0 w-1 h-1 opacity-0 pointer-events-none" autoplay playsinline muted></video>

    <!-- Main Canvas -->
    <div class="absolute inset-0 w-full h-full z-0 bg-black">
        <canvas id="mainCanvas" class="w-full h-full object-cover"></canvas>
    </div>

    <!-- START OVERLAY -->
    <div id="startOverlay" class="absolute inset-0 z-40 flex flex-col items-center justify-center bg-black/40 backdrop-blur-sm transition-opacity duration-300">
        <button id="startBtn" class="group relative flex items-center justify-center">
            <div class="absolute inset-0 rounded-full bg-red-500/30 animate-ping"></div>
            <div class="relative bg-white rounded-full p-2 shadow-2xl transition-transform transform group-active:scale-95">
                <div class="w-20 h-20 bg-red-600 rounded-full border-4 border-white flex items-center justify-center">
                    <div class="w-8 h-8 bg-white rounded-sm"></div> 
                </div>
            </div>
        </button>
        <div class="mt-8 text-white font-medium tracking-wide text-lg drop-shadow-md">Tap to Start Capture</div>
    </div>

    <!-- Top Status Pill -->
    <div id="topPillContainer" class="absolute top-6 left-0 w-full flex justify-center pointer-events-none z-20 transition-opacity duration-300 opacity-0">
        <div class="bg-white/30 backdrop-blur-2xl border border-white/20 px-4 py-1.5 rounded-full flex items-center gap-2 shadow-lg">
            <div id="statusLive" class="flex items-center gap-2">
                <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                <span class="text-gray-900 text-xs font-medium tracking-wide drop-shadow-sm">REC</span>
                <span id="liveTimer" class="text-gray-700 text-xs font-mono pl-2 border-l border-gray-500/30">0:00.0</span>
            </div>
            <div id="statusHistory" class="hidden items-center gap-2">
                <div class="w-2 h-2 bg-blue-500 rounded-full"></div>
                <span class="text-gray-900 text-xs font-medium tracking-wide drop-shadow-sm">REVIEW</span>
                <span id="historyTimer" class="text-gray-700 text-xs font-mono pl-2 border-l border-gray-500/30">0:00.0 / 0:00.0</span>
            </div>
        </div>
    </div>

    <!-- Floating Control Island -->
    <div id="controlIsland" class="absolute bottom-8 left-6 right-6 bg-white/30 backdrop-blur-2xl rounded-[2rem] shadow-2xl z-30 transition-all duration-300 border border-white/20 flex flex-col overflow-hidden h-48 translate-y-[150%]">
        
        <!-- Toggle Minimize -->
        <button id="toggleMinimizeBtn" class="absolute top-0 right-0 p-4 text-gray-800 hover:text-black transition-colors z-40 outline-none">
            <svg id="iconMinimize" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
            <svg id="iconMaximize" class="hidden" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>
        </button>

        <!-- Minimized Content (Hidden by default via 'hidden' class to prevent overlap) -->
        <div id="minimizedContent" class="hidden absolute inset-0 flex items-center pl-6 pr-14 transition-opacity duration-300">
            <div class="flex items-center gap-3 overflow-hidden whitespace-nowrap">
                <div id="minimizedIndicator" class="w-2.5 h-2.5 min-w-[0.625rem] rounded-full bg-red-500 animate-pulse"></div>
                <span id="minimizedText" class="text-sm font-semibold text-gray-900 drop-shadow-sm truncate">Recording...</span>
                <span id="minimizedTimer" class="text-xs font-mono text-gray-600 border-l border-gray-500/30 pl-3 ml-1">0:00.0</span>
            </div>
        </div>

        <!-- Expanded Content -->
        <div id="expandedContent" class="flex flex-col h-full px-8 pb-6 pt-5 transition-opacity duration-200">
            
            <div class="flex justify-between items-center mb-auto">
                <div class="flex items-center gap-2">
                    <!-- Stop Button -->
                    <button id="stopBtn" class="flex items-center gap-1 text-red-700 hover:text-red-900 active:scale-95 transition-all font-medium text-sm bg-red-50/50 px-3 py-1.5 rounded-full border border-red-100/50 backdrop-blur-sm">
                        <div class="w-3 h-3 bg-red-600 rounded-sm mr-1"></div>
                        Stop Capture
                    </button>

                    <!-- Return to Live Button -->
                    <button id="returnLiveBtn" class="hidden flex items-center gap-1 text-blue-700 hover:text-blue-900 active:scale-95 transition-all font-medium text-sm bg-blue-50/50 hover:bg-blue-50/80 px-3 py-1.5 rounded-full border border-blue-100/50 backdrop-blur-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                        Return to Live
                    </button>

                    <!-- New Session Button -->
                    <button id="newSessionBtn" class="hidden flex items-center gap-1 text-gray-700 hover:text-black active:scale-95 transition-all font-medium text-sm bg-gray-50/50 px-3 py-1.5 rounded-full border border-gray-100/50 backdrop-blur-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        New Session
                    </button>
                    
                    <!-- Recording Label -->
                    <span id="recordingStatus" class="ml-2 text-xs font-bold text-gray-500 uppercase tracking-wider flex items-center gap-1.5 whitespace-nowrap">
                        Recording Live
                    </span>
                </div>

                <!-- Download Button -->
                <button id="downloadBtn" class="hidden flex items-center gap-1 text-blue-700 hover:text-blue-900 active:scale-95 transition-all font-bold text-sm bg-blue-50/50 px-4 py-1.5 rounded-full border border-blue-100/50 backdrop-blur-sm shadow-sm ml-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    Download
                </button>
            </div>

            <!-- Slider -->
            <div class="relative w-auto mx-4 h-14 flex items-center justify-center group mt-2">
                <div class="absolute top-1/2 -translate-y-1/2 w-full h-2 bg-gray-400/40 rounded-full overflow-hidden backdrop-blur-sm">
                    <div id="trackFill" class="h-full transition-all duration-150 bg-red-500/90" style="width: 100%"></div>
                </div>

                <div id="floatingTimestamp" class="hidden absolute top-0 px-2.5 py-1 bg-black/80 text-white text-[10px] font-mono font-bold rounded shadow-lg pointer-events-none transition-all duration-75 z-40 backdrop-blur-md" style="left: 50%; transform: translateX(-50%) translateY(-80%);">
                    <span id="floatingTimeText">0:00.0</span>
                    <div class="absolute top-full left-1/2 transform -translate-x-1/2 -mt-0.5 border-4 border-transparent border-t-black/80"></div>
                </div>

                <input id="timelineSlider" type="range" min="0" max="0" step="1" value="0" class="absolute w-full h-full opacity-0 z-30">

                <div id="sliderThumb" class="absolute top-1/2 h-8 w-8 bg-white rounded-full shadow-lg border border-white/50 z-20 pointer-events-none transition-transform duration-150" style="left: 100%; transform: translate(-50%, -50%);">
                    <div id="thumbDot" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-2 h-2 rounded-full bg-red-500"></div>
                </div>
            </div>

            <div class="text-center mt-1">
                <span id="bufferInfo" class="text-[10px] text-gray-600 font-medium uppercase tracking-widest drop-shadow-sm">
                    Ready to Capture
                </span>
            </div>
        </div>
    </div>

    <!-- Error Overlay -->
    <div id="errorOverlay" class="hidden absolute inset-0 bg-black/80 flex items-center justify-center p-6 z-50">
        <div class="bg-white/10 backdrop-blur-lg p-6 rounded-2xl text-center border border-white/20">
            <p id="errorMessage" class="text-white text-sm">Error</p>
            <button onclick="location.reload()" class="mt-4 bg-white text-black px-4 py-2 rounded-full text-sm font-medium">Reload</button>
        </div>
    </div>

    <script>
        const CAPTURE_INTERVAL_MS = 100;
        
        let frames = []; 
        let bufferSize = 0;
        let playbackIndex = -1; 
        let isCapturing = false;
        let isLiveView = true;
        let isDragging = false;
        let isMinimized = false;
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoBlobUrl = null;
        let captureInterval = null;
        let offscreenCanvas = null;
        
        const videoEl = document.getElementById('sourceVideo');
        const canvasEl = document.getElementById('mainCanvas');
        const ctx = canvasEl.getContext('2d');
        
        const startOverlay = document.getElementById('startOverlay');
        const controlIsland = document.getElementById('controlIsland');
        const topPillContainer = document.getElementById('topPillContainer');
        
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const returnLiveBtn = document.getElementById('returnLiveBtn');
        const newSessionBtn = document.getElementById('newSessionBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const toggleMinimizeBtn = document.getElementById('toggleMinimizeBtn');
        
        const liveTimerEl = document.getElementById('liveTimer');
        const historyTimerEl = document.getElementById('historyTimer');
        const statusLiveEl = document.getElementById('statusLive');
        const statusHistoryEl = document.getElementById('statusHistory');
        const recordingStatus = document.getElementById('recordingStatus');
        const bufferInfo = document.getElementById('bufferInfo');
        
        const timelineSlider = document.getElementById('timelineSlider');
        const trackFill = document.getElementById('trackFill');
        const sliderThumb = document.getElementById('sliderThumb');
        const thumbDot = document.getElementById('thumbDot');
        const floatingTimestamp = document.getElementById('floatingTimestamp');
        const floatingTimeText = document.getElementById('floatingTimeText');

        const minimizedContent = document.getElementById('minimizedContent');
        const expandedContent = document.getElementById('expandedContent');
        const minimizedIndicator = document.getElementById('minimizedIndicator');
        const minimizedText = document.getElementById('minimizedText');
        const minimizedTimer = document.getElementById('minimizedTimer');
        const iconMinimize = document.getElementById('iconMinimize');
        const iconMaximize = document.getElementById('iconMaximize');

        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true, 
                    video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                videoEl.srcObject = stream;
                await videoEl.play();
                videoEl.muted = true; 
            } catch (err) {
                console.error(err);
                document.getElementById('errorOverlay').classList.remove('hidden');
                document.getElementById('errorMessage').innerText = "Camera Access Denied: " + err.message;
            }
        }

        function startSession() {
            frames = [];
            recordedChunks = [];
            bufferSize = 0;
            playbackIndex = -1;
            isCapturing = true;
            isLiveView = true;
            if (videoBlobUrl) URL.revokeObjectURL(videoBlobUrl);
            videoBlobUrl = null;

            startOverlay.classList.add('opacity-0', 'pointer-events-none');
            controlIsland.classList.remove('translate-y-[150%]');
            topPillContainer.classList.remove('opacity-0');
            
            stopBtn.classList.remove('hidden');
            returnLiveBtn.classList.add('hidden');
            newSessionBtn.classList.add('hidden');
            downloadBtn.classList.add('hidden');
            recordingStatus.classList.remove('hidden');
            timelineSlider.disabled = false; 

            try {
                const stream = videoEl.srcObject;
                const options = MediaRecorder.isTypeSupported('video/mp4') ? { mimeType: 'video/mp4' } : { mimeType: 'video/webm' };
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.start(1000);
            } catch (e) {
                console.error("MediaRecorder failed", e);
            }

            clearInterval(captureInterval);
            captureInterval = setInterval(captureFrame, CAPTURE_INTERVAL_MS);
            
            updateUI();
        }

        function stopSession() {
            isCapturing = false;
            isLiveView = false; 
            
            clearInterval(captureInterval);
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            playbackIndex = bufferSize;

            stopBtn.classList.add('hidden');
            returnLiveBtn.classList.add('hidden');
            recordingStatus.classList.add('hidden');
            
            newSessionBtn.classList.remove('hidden');
            downloadBtn.classList.remove('hidden');

            updateUI();
        }

        function returnToLive() {
            isLiveView = true;
            playbackIndex = -1;
            updateUI();
        }

        function downloadVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `capture-${new Date().getTime()}.mp4`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }

        function captureFrame() {
            if (videoEl.readyState < 2) return;

            const w = videoEl.videoWidth / 2;
            const h = videoEl.videoHeight / 2;

            if (!offscreenCanvas) offscreenCanvas = document.createElement('canvas');
            if (offscreenCanvas.width !== w) {
                offscreenCanvas.width = w;
                offscreenCanvas.height = h;
            }

            const offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
            offCtx.drawImage(videoEl, 0, 0, w, h);
            
            const frameData = offCtx.getImageData(0, 0, w, h);
            frames.push(frameData);
            bufferSize = frames.length;
            
            updateUI();
        }

        function render() {
            const w = videoEl.videoWidth / 2;
            const h = videoEl.videoHeight / 2;
            
            if (videoEl.readyState >= 2) {
                if (canvasEl.width !== w) canvasEl.width = w;
                if (canvasEl.height !== h) canvasEl.height = h;

                if (isLiveView) {
                    ctx.drawImage(videoEl, 0, 0, w, h);
                } else {
                    const idx = playbackIndex === -1 ? bufferSize - 1 : playbackIndex;
                    const safeIndex = Math.max(0, Math.min(idx, frames.length - 1));
                    const frame = frames[safeIndex];
                    if (frame) ctx.putImageData(frame, 0, 0);
                }
            }
            requestAnimationFrame(render);
        }

        function formatTime(frameIndex) {
            const totalSeconds = (frameIndex * CAPTURE_INTERVAL_MS) / 1000;
            const mins = Math.floor(totalSeconds / 60);
            const secs = Math.floor(totalSeconds % 60);
            const ms = Math.floor((totalSeconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        function updateUI() {
            const currentIndex = isLiveView ? bufferSize : playbackIndex;
            const timeStr = formatTime(currentIndex);
            const totalTimeStr = formatTime(bufferSize);

            liveTimerEl.innerText = totalTimeStr;
            historyTimerEl.innerText = `${timeStr} / ${totalTimeStr}`;
            minimizedTimer.innerText = totalTimeStr;
            
            if (isCapturing) {
                 bufferInfo.innerText = isLiveView ? 
                    `Recording Live: ${((bufferSize * CAPTURE_INTERVAL_MS)/1000).toFixed(1)}s` : 
                    `Reviewing Past (${((bufferSize * CAPTURE_INTERVAL_MS)/1000).toFixed(1)}s)...`;
            } else {
                 bufferInfo.innerText = `Session Total: ${((bufferSize * CAPTURE_INTERVAL_MS)/1000).toFixed(1)}s`;
            }

            timelineSlider.max = bufferSize;
            if (isLiveView && !isDragging) {
                timelineSlider.value = bufferSize;
            } else if (!isDragging) {
                timelineSlider.value = playbackIndex;
            }
            
            const percent = bufferSize === 0 ? 0 : (currentIndex / bufferSize) * 100;
            trackFill.style.width = `${percent}%`;
            sliderThumb.style.left = `${percent}%`;
            floatingTimestamp.style.left = `${percent}%`;

            if (isLiveView) {
                trackFill.classList.replace('bg-blue-600/90', 'bg-red-500/90') || trackFill.classList.add('bg-red-500/90');
                thumbDot.classList.replace('bg-blue-600', 'bg-red-500') || thumbDot.classList.add('bg-red-500');
                
                statusLiveEl.classList.remove('hidden'); statusLiveEl.classList.add('flex');
                statusHistoryEl.classList.remove('flex'); statusHistoryEl.classList.add('hidden');
                
                minimizedIndicator.className = "w-2.5 h-2.5 min-w-[0.625rem] rounded-full bg-red-500 animate-pulse";
                minimizedText.innerText = isCapturing ? "Recording Live" : "Ready";
                
                floatingTimestamp.classList.add('hidden');
                
                if(isCapturing) {
                    stopBtn.classList.remove('hidden');
                    returnLiveBtn.classList.add('hidden');
                    recordingStatus.classList.remove('hidden');
                }

            } else {
                trackFill.classList.replace('bg-red-500/90', 'bg-blue-600/90');
                thumbDot.classList.replace('bg-red-500', 'bg-blue-600');
                
                statusLiveEl.classList.remove('flex'); statusLiveEl.classList.add('hidden');
                statusHistoryEl.classList.remove('hidden'); statusHistoryEl.classList.add('flex');

                minimizedIndicator.className = "w-2.5 h-2.5 min-w-[0.625rem] rounded-full bg-blue-500";
                minimizedText.innerText = isCapturing ? "Recording (Review)" : "Session Review";
                
                floatingTimestamp.classList.remove('hidden');
                floatingTimeText.innerText = timeStr;
                
                if(isCapturing) {
                    stopBtn.classList.add('hidden');
                    returnLiveBtn.classList.remove('hidden');
                    recordingStatus.classList.add('hidden');
                }
            }
        }

        startBtn.addEventListener('click', startSession);
        stopBtn.addEventListener('click', stopSession);
        returnLiveBtn.addEventListener('click', returnToLive);
        newSessionBtn.addEventListener('click', () => {
            controlIsland.classList.add('translate-y-[150%]');
            topPillContainer.classList.add('opacity-0');
            startOverlay.classList.remove('opacity-0', 'pointer-events-none');
        });
        downloadBtn.addEventListener('click', downloadVideo);

        timelineSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value, 10);
            if (val >= bufferSize - 1) {
                isLiveView = true;
                playbackIndex = -1;
            } else {
                isLiveView = false;
                playbackIndex = val;
            }
            updateUI();
        });

        timelineSlider.addEventListener('mousedown', () => isDragging = true);
        timelineSlider.addEventListener('mouseup', () => isDragging = false);
        timelineSlider.addEventListener('touchstart', () => isDragging = true);
        timelineSlider.addEventListener('touchend', () => isDragging = false);

        // TOGGLE MINIMIZE LOGIC with DISPLAY:NONE management
        toggleMinimizeBtn.addEventListener('click', () => {
            isMinimized = !isMinimized;
            if (isMinimized) {
                // Minimize
                controlIsland.classList.replace('h-48', 'h-16');
                iconMinimize.classList.add('hidden'); iconMaximize.classList.remove('hidden');
                topPillContainer.classList.add('opacity-0');

                // Hide Expanded Content completely
                expandedContent.classList.add('hidden'); 
                
                // Show Minimized Content
                minimizedContent.classList.remove('hidden');
                // Trigger reflow for transition? (Optional, simplified here for strict non-overlap)
                requestAnimationFrame(() => {
                     minimizedContent.classList.remove('opacity-0');
                });

            } else {
                // Expand
                controlIsland.classList.replace('h-16', 'h-48');
                iconMinimize.classList.remove('hidden'); iconMaximize.classList.add('hidden');
                topPillContainer.classList.remove('opacity-0');

                // Hide Minimized Content
                minimizedContent.classList.add('hidden');
                minimizedContent.classList.add('opacity-0');

                // Show Expanded Content
                expandedContent.classList.remove('hidden');
                // Slight delay for opacity to animate if desired, but 'hidden' toggles instantly
                expandedContent.classList.remove('opacity-0');
            }
        });

        initCamera();
        requestAnimationFrame(render);

    </script>
</body>
</html>
